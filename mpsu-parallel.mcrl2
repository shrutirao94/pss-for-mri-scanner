sort
    Modes = struct Normal | Emergency;
    Motor2Status = struct moveLeft | moveRight | stopped2;
    Motor1Status = struct moveUp | moveDown | stopped1;
    Inputs = struct pressStop | pressResume | pressUndock | pressReset;
    Operations = struct opInEmg | opInNorm | opUndock;


act
    read1, send2, read2, com2: Inputs;
    send3, read3, com3: Operations;
    motor2Off, releaseBreak2, applyBreak2, unlockDock;

proc
    Console
		= sum input:Inputs. read1(input).send2(input).Console;

    Sensor(mode:Modes, docked, calibrated, rightMost:Bool, m2s:Motor2Status)
        = sum input:Inputs. read2(input).
    		((docked && input == pressStop)
                -> send3(opInEmg).Sensor(mode = Emergency, m2s = stopped2)
    		+ (docked && input == pressResume)
                -> send3(opInNorm).Sensor(mode = Normal)
            + (docked && input == pressUndock && rightMost)
                -> send3(opUndock).Sensor(docked = false)
            + (docked && mode == Normal && !calibrated)
                -> Sensor(calibrated = true)
    		+ (!docked && mode == Normal)
                -> Sensor(calibrated = false)
    		<> Sensor(mode, docked, calibrated, rightMost, m2s));

    Hardware
        = sum input:Operations. read3(input).
            ((input == opInEmg)
	            -> releaseBreak2.motor2Off.Hardware
            + (input == opInNorm)
	            -> applyBreak2.Hardware
            + (input == opUndock)
                -> applyBreak2.unlockDock
			<> Hardware);

init
    allow({read1, com2, com3},
        comm({
                send2|read2 -> com2,
                send3|read3 -> com3
            },
        Console || Sensor(Normal, true, true, false, stopped2) || Hardware
    ));
